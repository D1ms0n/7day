# -*- coding: utf-8 -*-from django.shortcuts import renderfrom django.http import HttpResponsefrom rest_framework.renderers import JSONRendererfrom django.views.decorators.csrf import csrf_exempt, csrf_protectimport jsonimport timeimport osimport refrom logger import Loggerfrom worker import Workerfrom django_datastore import get_users_from_database, get_tasks_from_databasefrom .models import InstaUserfrom .models import InstaBotTaskfrom .models import InstaMediafrom .models import InstaShopItemfrom .models import Orderfrom .models import OrderItemfrom .serializers import InstaUserSerializerfrom .serializers import InstaBotTaskSerializerfrom .serializers import InstaMediaSerializerfrom .serializers import InstaShopItemSerializerfrom .serializers import OrderSerializer#from .serializers import OrderItemSerializerfrom rest_framework import genericsfrom rest_framework import pagination# kostilifrom rest_framework.response import Responsefrom rest_framework import statuslogin = 'studio_7_day_2'password = 'Nopasaran'def get_base_dir():    return os.path.dirname(os.path.dirname(os.path.abspath(__file__)))worker = Worker(login, password)logger = Logger('view')time_now = time.strftime('%X %x').replace(' ', '_').replace('/', '_').replace(':', '_')def main(request):    return render(request, 'studio/test_front.html', {})def insta_shop(request):    name = 'studio_7_day_2'    tag  = '#minimal'    tag_regex      = re.compile(r'#\S+')    price_regex    = re.compile(r'(?i)(?P<price>(?:цена|price) *:* *\d+)')    category_regex = re.compile(tag + '_(\S+)')    name_regex     = re.compile(r'(?i)(?P<name>^.+?\.)')    medias = worker.get_medias(name)    for media in medias:        author = InstaUser.objects.get(user_name= name)        caption = media['caption']        if media['is_video']== True:            continue        if tag not in media['caption']:            continue        try:            media = InstaMedia.objects.get(image_id = media['id'])        except:            media = InstaMedia(image_id = media['id'],                               display_src= media['display_src'],                               caption = caption,                               image_author = author,                               images_likes_count = media['likes']['count'],                               code               = media['code']                               )            media.save()        try:            item = InstaShopItem.objects.get(media = media)        except:            price = 'No price'            category = 'main'            item_name = ''            name_search = re.search(name_regex, caption)            if name_search:                name = name_search.group('name')            category_search = re.search(category_regex, caption)            if category_search:                category = category_search.group(1)            price_search = re.search(price_regex, caption)            if price_search:                price = price_search.group('price')                caption = caption.replace(price, '')            tags_search = re.findall(tag_regex, caption)            if tags_search:                logger.log(tags_search)                for tag in tags_search:                    caption = caption.replace(str(tag), '')            item = InstaShopItem(name = item_name,                                 media = media,                                 price = price,                                 description = caption,                                 category = category)            item.save()        all_media = InstaMedia.objects.filter(image_author__user_name = name)        for media in all_media:            media_info = worker.get_media_info(code = media.code)            logger.log(media_info['status_code'])            if media_info['status_code'] != 200:                media.delete()    return render(request, 'studio/insta_shop.html', {})def api_test(request):    return render(request, 'studio/api_test.html',{})def react_app(request):    return render(request, 'studio/insta_users_r.html', {})@csrf_exemptdef run_task(request, task_id):    logger.log('VIEWS:runtask: ' + task_id )    worker.run_task(task_id)    return render(request, 'studio/insta_users_r.html', {})class InstaUserList(generics.ListCreateAPIView):    serializer_class = InstaUserSerializer    renderer_classes = (JSONRenderer,)    pagination_class = pagination.PageNumberPagination    def get_queryset(self):        print self.request.query_params        queryset = get_users_from_database(self.request.query_params)        return querysetclass InstaUserDetail(generics.RetrieveAPIView):    queryset = InstaUser.objects.all()    renderer_classes = (JSONRenderer,)    serializer_class = InstaUserSerializer    lookup_field = 'user_id'class InstaMediaList(generics.ListCreateAPIView):    serializer_class = InstaMediaSerializer    renderer_classes = (JSONRenderer,)    def get_queryset(self):        return InstaMedia.objects.all()class InstaShopItemList(generics.ListCreateAPIView):    serializer_class = InstaShopItemSerializer    renderer_classes = (JSONRenderer,)    def get_queryset(self):        category = self.request.query_params.get('category')        if category:            items = InstaShopItem.objects.filter(category = category)        else:            items = InstaShopItem.objects.all()        return itemsclass InstaUserFollowers(generics.ListCreateAPIView):    serializer_class = InstaUserSerializer    renderer_classes = (JSONRenderer,)    def get_queryset(self):        params = self.request.query_params.dict()        params['followed_user'] = self.kwargs['user_id']        queryset = get_users_from_database(params)        return querysetclass InstaUserFollowedBy(generics.ListCreateAPIView):    serializer_class = InstaUserSerializer    renderer_classes = (JSONRenderer,)    def get_queryset(self):        params = self.request.query_params.dict()        params['followed_by_user'] = self.kwargs['user_id']        queryset = get_users_from_database(params)        return querysetclass InstaBotTaskList(generics.ListCreateAPIView):    serializer_class = InstaBotTaskSerializer    renderer_classes = (JSONRenderer,)    def get_queryset(self):        return  InstaBotTask.objects.filter(**self.request.query_params.dict())        #params = self.request.query_params.dict()        #return  get_tasks_from_database(params)    def create(self, request, *args, **kwargs):        logger.log(request.data)        targets = request.data.pop('targets')        request.data["targets"] = [{"user_name": target} for target in targets]        logger.log(request.data)        serializer = self.get_serializer(data=request.data)        serializer.is_valid(raise_exception=True)        self.perform_create(serializer)        headers = self.get_success_headers(serializer.data)        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)    def perform_create(self, serializer):        time_now = time.strftime('%X %x').replace(' ', '_').replace('/', '_')        serializer.save(task_id = abs(hash(time_now)), create_time = time_now, status= 'Created')class InstaBotTaskDetail(generics.RetrieveAPIView):        queryset         = InstaBotTask.objects.all()        serializer_class = InstaBotTaskSerializer        renderer_classes = (JSONRenderer,)        lookup_field     = 'task_id'class InstaBotTaskUserList(generics.RetrieveAPIView):    user_ids = InstaUser    queryset = InstaBotTask.objects.all()    serializer_class = InstaBotTaskSerializer    renderer_classes = (JSONRenderer,)    lookup_field = 'task_id'class OrderList(generics.ListCreateAPIView):    serializer_class = OrderSerializer    renderer_classes = (JSONRenderer,)    def get_queryset(self):        return Order.objects.all()    def create(self, request, *args, **kwargs):        items = request.data.pop('items')        order = Order(**request.data)        order.save()        for item in items:            shop_item =  InstaShopItem.objects.get(id = item['id'])            OrderItem.objects.create(shop_item = shop_item,                                     order = order,                                     count = item['count'])        serializer = self.get_serializer(order)        return Response(serializer.data)class OrderDetail(generics.RetrieveAPIView):    queryset = Order.objects.all()    serializer_class = OrderSerializer    renderer_classes = (JSONRenderer,)    lookup_field = 'id'########################################################################################### OLD INSTA_API ###########################################################################@csrf_exemptdef insta_api(request, target, request_id='', **kwargs):    logger.log('VIEW:insta_api: start at %s %s/%s' % (str(time_now), target, request_id))    ##################### GET ##################################    # GET / get_list    if request.method == 'GET':        if target == 'get_tasks':            task_list = get_tasks_from_database()            return HttpResponse(json.dumps(task_list),                                content_type="application/json")        elif target == 'get_task_result':            result = worker.get_task_result(task_id=request_id)            return HttpResponse(json.dumps(result),                                content_type="application/json")    #################### POST ##################################     elif request.method == 'POST':        request_json = json.loads(request.body)        # POST / add_task        if target == 'add_task':            time_now = time.strftime('%X %x').replace(' ', '_').replace('/', '_')            task_id = abs(hash(time_now))            direction = request_json['direction']            if direction in ['following', 'followers']:                username = request_json['username']                if 'count' in request_json:                    count = request_json['count']                else:                    count = 50                worker.create_new_task(task_id=task_id, direction=direction, username=username, count=count,                                       create_time=time_now)                worker.get_follow_info(username, direction, count, task_id)  # TODO: queue for tasks            elif direction in ['follow', 'unfollow']:                user_names = request_json['user_names']                worker.create_new_task(task_id=task_id, direction=direction, username='None', count='None',                                       create_time=time_now)                worker.change_relationships(user_names, direction, task_id)            task_list = worker.get_tasks()            return HttpResponse(json.dumps(task_list),                                content_type="application/json")def tasks(request):    return render(request, 'studio/tasks.html', {})def task(request, id):    return render(request, 'studio/task.html', {})def logs(request):    try:        result_file = open('%s/LOG' % os.path.join(get_base_dir(), 'studioapp', 'logs'))        log = result_file.readlines()    except:        log = []    return render(request, 'studio/logs.html', {'log': log[-50:]})def users_table(request):    users = InstaUser.objects.all()    return render(request, 'studio/Insta_users.html', {'users': users})